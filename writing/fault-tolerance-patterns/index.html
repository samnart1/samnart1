<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fault Tolerance Patterns in Microservices — Sam Nart</title>
    <meta name="description" content="An exploration of fault tolerance patterns in distributed microservices systems, including circuit breakers, bulkheads, and retry mechanisms.">

    <meta property="og:title" content="Fault Tolerance Patterns in Microservices — Sam Nart">
    <meta property="og:description" content="An exploration of fault tolerance patterns in distributed microservices systems.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://samnart.website/writing/fault-tolerance-patterns/">

    <link rel="icon" type="image/svg+xml" href="/images/favicon.svg">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Newsreader:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div id="nav" aria-busy="true"></div>

    <main class="page">
        <div class="container container--narrow">
            <article class="article">
                <header class="article__header">
                    <h1 class="article__title">Fault Tolerance Patterns in Microservices</h1>
                    <div class="article__meta">
                        <span class="article__date">Dec 2025</span>
                        <span class="article__reading-time">12 min read</span>
                    </div>
                </header>

                <div class="article__content">
                    <p>
                        Distributed systems fail. Not sometimes, not occasionally—they fail constantly in ways you didn't anticipate. Network partitions, cascading failures, resource exhaustion, slow responses that are worse than no response at all. When I started researching fault tolerance for my Master's thesis, I thought I understood these problems. I didn't.
                    </p>

                    <p>
                        This article distills what I've learned from benchmarking fault tolerance patterns in Spring Boot microservices. The goal isn't to provide an exhaustive taxonomy—plenty of resources do that. Instead, I want to share the practical insights that only become apparent when you actually implement and stress-test these patterns.
                    </p>

                    <h2>The Fundamental Problem</h2>

                    <p>
                        In a monolithic application, a method call either succeeds or throws an exception. The failure mode is binary and immediate. In a distributed system, you add a third state: <em>unknown</em>. Did the request succeed? Did it fail? Is it still in progress? You might never know.
                    </p>

                    <p>
                        This uncertainty is the root of every fault tolerance pattern. Each pattern is essentially a strategy for dealing with uncertainty while preventing it from cascading through your system.
                    </p>

                    <h2>Circuit Breakers: Failing Fast</h2>

                    <p>
                        The circuit breaker pattern is deceptively simple: if a dependency fails repeatedly, stop calling it. Let it recover. Check back later.
                    </p>

<pre><code>@CircuitBreaker(name = "inventoryService", fallbackMethod = "fallbackInventory")
public InventoryStatus checkInventory(String productId) {
    return inventoryClient.getStatus(productId);
}</code></pre>

                    <p>
                        What the textbooks don't tell you is how to tune the parameters. After running extensive benchmarks, here's what I found:
                    </p>

                    <ul>
                        <li><strong>Failure rate threshold:</strong> 50% is often too high. By the time half your requests fail, you've already degraded user experience significantly. Consider 30-40%.</li>
                        <li><strong>Slow call threshold:</strong> This is more important than failure rate. A service that responds slowly ties up threads and can cascade failures faster than one that fails outright.</li>
                        <li><strong>Wait duration in open state:</strong> Start with 30 seconds, not 60. Modern services recover quickly, and long wait times frustrate users.</li>
                        <li><strong>Half-open state requests:</strong> Allow 3-5 requests, not just 1. A single successful request doesn't prove recovery.</li>
                    </ul>

                    <h2>Bulkheads: Isolating Failures</h2>

                    <p>
                        The bulkhead pattern limits the blast radius of failures by isolating components. If your payment service is struggling, it shouldn't affect your product catalog.
                    </p>

                    <p>
                        There are two main approaches: thread pool isolation and semaphore isolation. Through benchmarking, I found that the choice matters more than I expected:
                    </p>

                    <p>
                        <strong>Thread pool isolation</strong> provides true isolation but adds overhead. Each call crosses thread boundaries, which adds latency and memory pressure. In my tests, thread pool bulkheads added 2-5ms of latency under normal conditions.
                    </p>

                    <p>
                        <strong>Semaphore isolation</strong> uses the caller's thread and only limits concurrent access. It's lighter but provides weaker isolation. If the protected code blocks, you're blocking the caller's thread.
                    </p>

                    <p>
                        My recommendation: use semaphores by default, thread pools only for calls to services that are known to have highly variable latency or are outside your control.
                    </p>

                    <h2>Retry: The Double-Edged Sword</h2>

                    <p>
                        Retry is the most dangerous pattern because it feels so intuitive. Request failed? Try again. What could go wrong?
                    </p>

                    <p>
                        Everything. Retries can turn a minor hiccup into a complete system failure. Here's why:
                    </p>

                    <div class="note">
                        <p>
                            <strong>The retry amplification problem:</strong> If you have 3 services in a chain, each with 3 retries, a single user request can generate up to 27 downstream requests. Under load, this creates a feedback loop that overwhelms the struggling service.
                        </p>
                    </div>

                    <p>
                        Rules I've learned the hard way:
                    </p>

                    <ol>
                        <li><strong>Never retry without backoff.</strong> Exponential backoff with jitter is non-negotiable.</li>
                        <li><strong>Set a retry budget.</strong> If more than 10% of your requests are retries, stop retrying and fail fast.</li>
                        <li><strong>Retries must be idempotent.</strong> If you can't guarantee idempotency, don't retry. Ever.</li>
                        <li><strong>Consider retry at the edge only.</strong> Let the API gateway retry; internal services should fail fast.</li>
                    </ol>

<pre><code>@Retry(name = "orderService", fallbackMethod = "fallbackOrder")
@CircuitBreaker(name = "orderService")
public Order createOrder(OrderRequest request) {
    // Circuit breaker wraps retry - order matters!
    return orderClient.create(request);
}</code></pre>

                    <h2>Timeouts: The Foundation</h2>

                    <p>
                        Every other pattern depends on timeouts. Without them, a slow service can hold connections indefinitely, exhausting your thread pool and cascading failures upstream.
                    </p>

                    <p>
                        The hardest part of timeouts is choosing values. Too short and you generate false failures. Too long and you don't provide protection. My approach:
                    </p>

                    <ul>
                        <li>Measure p99 latency under normal load</li>
                        <li>Set timeout to 2-3x p99</li>
                        <li>Monitor timeout rates and adjust</li>
                        <li>Different timeouts for different operations—reads vs writes, critical vs non-critical</li>
                    </ul>

                    <h2>Fallbacks: Graceful Degradation</h2>

                    <p>
                        Fallbacks determine what happens when a pattern triggers. A good fallback provides degraded but acceptable functionality:
                    </p>

                    <ul>
                        <li><strong>Return cached data</strong> (even if stale)</li>
                        <li><strong>Return a default value</strong> (empty list, placeholder image)</li>
                        <li><strong>Queue for later processing</strong> (eventual consistency)</li>
                        <li><strong>Return an honest error</strong> (sometimes the best option)</li>
                    </ul>

                    <p>
                        Avoid fallbacks that call other remote services—they can fail too, creating nested fallback chains that are impossible to reason about.
                    </p>

                    <h2>Putting It Together</h2>

                    <p>
                        These patterns work together but must be layered correctly. From innermost to outermost:
                    </p>

                    <ol>
                        <li><strong>Timeout</strong> — Prevents indefinite waiting</li>
                        <li><strong>Retry</strong> — Handles transient failures</li>
                        <li><strong>Circuit Breaker</strong> — Prevents cascade during persistent failures</li>
                        <li><strong>Bulkhead</strong> — Isolates impact to specific components</li>
                    </ol>

                    <p>
                        This order matters. You want retries to happen before the circuit breaker trips, and you want the circuit breaker to prevent retries when the service is truly down.
                    </p>

                    <h2>What I Learned</h2>

                    <p>
                        After months of benchmarking and testing, my main takeaway is this: <strong>fault tolerance is not a library feature—it's an architectural decision</strong>.
                    </p>

                    <p>
                        Adding Resilience4j annotations to your code gives you tools, not solutions. The real work is understanding your system's failure modes, measuring behavior under stress, and tuning parameters based on actual data.
                    </p>

                    <p>
                        You can find the benchmarking framework I built for this research at <a href="https://github.com/samnart/resilience-benchmark">resilience-benchmark</a>. It's designed to inject failures and measure how different pattern configurations respond. If you're implementing fault tolerance in your own systems, I hope it's useful.
                    </p>

                    <hr>

                    <p>
                        <em>This article summarizes research from my Master's thesis at UniBZ. The full thesis includes detailed benchmark results, statistical analysis, and recommendations for specific use cases.</em>
                    </p>
                </div>

                <footer class="article__footer">
                    <a href="/writing/" class="article__back">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                        </svg>
                        Back to Writing
                    </a>
                </footer>
            </article>
        </div>
    </main>

    <div id="footer" aria-busy="true"></div>

    <script src="/js/main.js"></script>
    <script src="/js/include.js"></script>
</body>
</html>
